## 查询数据
本章节想您介绍使用 SQL 的相关信息。
This topic provides information about using SQL in Greenplum databases.

You enter SQL statements called queries to view, change, and analyze data in a database using the psql interactive SQL client and other client tools.

* About Greenplum Query Processing
* About the Pivotal Query Optimizer
* Defining Queries
* Using Functions and Operators
* Query Performance
* Managing Spill Files Generated by Queries
* Query Profiling

### 数据处理简介
本主题为您介绍 <&product-name> 是如何处理查询请求的。理解查询处理的过程，对您编写和优化查询有非常巨大的帮助。

用户向 <&product-name> 发送查询命令和使用其它数据库管理系统完全一样。通过使用客户端应用程序（例如：psql）连接 <&product-name> 主节点，您可以提供 SQL 语句命令。

Parent topic: Querying Data

#### 理解查询优化和查询分发
主节点负责接收，分析和优化用户查询。最终的执行计划可以是完全并行的，也可以是运行在特定节点的。如图todo对于并行查询计划，主节点将其发送到所有的计算节点上。如图todo所示，对于运行在特定节点的执行计划，主节点将会发送查询计划到一个单独的节点运行。每个计算节点只负责在自己对应的数据上进行相应的数据操作。
query plans

大多数的数据库操作是在所有计算节点并行进行的，例如：扫描数据表，连接运算，聚合运算和排序操作。每个计算节点的操作都不依赖存储在其它计算节点上的数据。

# TODO pic

一些查询可能只访问特定计算节点的数据，例如：单行插入，更新，删除或者是查询操作只涉及表中特定数据（过滤条件正好是表的数据分布键值）。对于上述的查询，查询计划不会发送给所有的计算节点，而是将查询计划发送给该查询影响的节点。

# TODO pic

#### 理解查询计划
查询计划就是 <&product-name> 为了计算查询结果的一系列操作的步骤。查询计划中的每个步骤（节点）代表了一种数据库操作，例如：表扫描，连接运算，聚合运算或者排序操作。查询计划的读取和执行都是自底向上的。

除了常见的操作外，<&product-name> 还支持一些特殊的操作：motion 节点（移动）。移动节点就是查询处理过程中，在不同计算节点直接移动数据。需要注意的是，不是所有的查询都需要数据移动的。例如：运行在特定节点的查询是不需要任何数据移动的。

为了能让查询执行获得最大的并行粒度，<&product-name> 通过将查询计划进行切片来进一步分解任务。每个切片都是可以被一个计算节点独立执行的查询计划子集。当查询计划中包含了数据移动节点时，查询计划就是被分片的。数据移动节点的上下两部分各自是一个独立的分片。

让我们来看下面这个例子：这是一个简单的两张表连接的运算：

	SELECT customer, amount
	FROM sales JOIN customer USING (cust_id)
	WHERE dateCol = '04-30-2008';

图todo 展示了查询计划。每个计算节点都会收到一份查询计划的拷贝，并且并行进行处理。

这个示例的查询计划包含了一个数据重分布的数据移动节点，该节点用来在不同计算节点直接移动记录使得连接运算得意完成。这里之所有需要数据重分布的节点，是因为 customer 表（用户表）的数据分布是通过 cust_id 来进行的，而 sales 表（销售表）是根据 sale_id 进行的。为了进行连接操作，sales 表的数据需要重新根据 cust_id 来分布。因此查询计划在数据重分布节点两侧被切片，分别是 slice 1 和 slice 2。

这个查询计划还包括了另一种数据移动节点：数据聚合节点。数据聚合节点是为了让所有的计算节点将结果发送给主节点，最后从主节点发送给用户引入的。由于查询计划总是在数据移动节点出现时被切片，这个查询计划还包括了一个隐藏的切片，该切片位于查询的最顶层（slice 3）。并不是所有的查询都包含数据聚合移动节点，例如：CREATE TABLE x AS SELECT ... 语句不需要使用数据聚合移动节点，这是因为数据将会移动到新创建的数据表中，而非主节点。


# TODO pic

#### 理解并行查询计划的执行
<&product-name> 将会创建多个数据库进程来处理查询的相关工作。在主节点上，查询工作进程被称为查询分派器（QD）。QD负责创建和分派查询计划。它同时负责收集和展示最终查询结果。在计算节点上，查询工作进程被称作查询执行起（QE）。QE 
负责执行分配给该进程的查询计划并通过通信模块将中间结果发送给其它工作进程。

每个查询计划的切片都至少会有一个工作进程与之对应负责执行。工作进程会被赋予不会互相依赖的查询计划片段。查询执行的过程中，每个计算节点都会有多个进程并行地参与查询的处理工作。

在不同计算节点上执行相同切片查询计划的工作进程被称为进程组。随着一部分工作的完成，数据记录将会从一个进程组流向其它进程组。这种在数据节点之间的进程间通信被称为互联组件。

图todo 想您展示对于图todo中查询计划在主节点和两个计算节点上的进程分布情况。

# TODO pic

### 查询的定义
<&product-name> 查询命令是基于 PostgreSQL 开发，而PostgreSQL 是实现了 SQL 标准。

本小结介绍如何在 <&product-name> 中编写 SQL 查询。

* SQL 
* SQL 值表达式
Parent topic: Querying Data

#### SQL Lexicon
SQL 是一种标准化的数据库访问语言。不同元素组构成的语言允许控制数据存储，数据获取，数据分析，数据变换和数据修改等。你需要通过使用 SQL 命令来编写 <&product-name> 理解的查询和命令。SQL 查询由一条或多条命令顺序组成。每一条命令是由多个词法元素组成正确的语法结构构成的，每条命令使用分号（;）分隔。

TODO: 参考语法参考手册

<&product-name> 在 PostgreSQL 的语法结构上进行了一些扩展，并根据分布式环境增加了部分的限制。如果您希望了解更多关于 PostgreSQL 中的 SQL 语法规则和概念，您可以参考 PostgreSQL 的文档中关于“SQL 语法”的章节。

#### SQL 值表达式
SQL 值表达式由一个或多个值，符号，运算符，SQL 函数和数据组成。表达式通过比较数据，执行计算病返回一个结果。
表达式计算包括：逻辑运算，算数运算和集合运算。

下面列出值表达式的类别：

* 聚合表达式
* 数组构造表达式
* 列引用
* 常亮或字面值
* 相关自查询
* 成员选择表达式
* 函数调用
* INSERT 或 UPDATE 语句中，为列提供的值
* 运算符调用
* 列引用
* 在函数体内或 Prepared 语句中引用位置参数
* 记录构造表达式
* 标量子查询
* WHERE 子句中的搜索条件
* SELECT 语句中的返回列表
* 类型转换
* 括号保护的子表达式
* 窗口表达式

像函数和运算符这样的 SQL 结构虽然属于表达式，但是与普通的语法规则不相同。请参考使用函数和运算符了解更多信息。

##### 列引用
列引用的格式如下：

	correlation.columnname
上面的示例中，correlation 是表的名称（也可以使用限定名格式：在表名前面添加模式名）或者定义在 FROM 子句中的表的别名。如果列名在查询访问的表中是唯一的，那么 "correlation." 部分是可以被省略的。

##### 位置参数
位置参数是指通过指定传递给 SQL 语句或函数参数的位置信息来引用的参数。例如：$1 引用第一个参数，$2 引用第二个参数，依此类推。位置参数的值是通过在 SQL 语句的外部参数传递或者通过函数调用方式传递。
Some client libraries support specifying data values separately from the SQL command, in which case parameters refer to the out-of-line data values. 引用位置参数的格式如下：

	$number
示例:

	CREATE FUNCTION dept(text) RETURNS dept
	    AS $$ SELECT * FROM dept WHERE name = $1 $$
	    LANGUAGE SQL;
这里, $1 引用的是在函数调用时，传递给函数的第一个参数值。

##### 下标表达式
如果一个表达式产生了一个数组类型值，那么你可以通过下面的方法获取数组中一个指定的元素值：

	expression[subscript]
您还可以获取多个相连的元素值，称为数组分片，示例如下：

	expression[lower_subscript:upper_subscript]
下标可以是一个表达式，该表达式必须返回整数值类型。

大部分时候，数组表达式必须在括号中使用。如果下标表达式访问列引用或者位置参数，括号是可以省略的。对于多维数组，可以直接连接多个下标表达式来进行访问，示例如下：

	mytable.arraycolumn[4]
	mytable.two_d_column[17][34]
	$1[10:42]
	(arrayfunction(a,b))[42]

##### 成员选择表达式
如果表达式的值是一个复合类型（例如：记录类型），你可以通过下面的表达式来选择该复合类型中的特定成员值：


	expression.fieldname
记录表达式通常需要在括号中使用，如果被访问的表达式是表引用或者位置参数，括号是可以省略的。示例：

	mytable.mycolumn
	$1.somecolumn
	(rowfunction(a,b)).col3
一个限定的列引用是成员选择表达式的特例。

##### 运算符调用
运算符调用支持下面的几种语法：

	expression operator expression(binary infix operator)
	operator expression(unary prefix operator)
	expression operator(unary postfix operator)
示例中的 operator 实际是运算符符号，例如：AND，OR，+等。运算符也有限定名格式，例如：

	OPERATOR(schema.operatorname)

可以使用的运算符以及他们究竟是一元运算符还是二元运算符，取决于系统和用户的定义。可以参考内建函数和运算符，了解更多信息。

##### 函数调用
函数调用的语法是函数名（限定名格式：在函数名开头添加模式名）跟随着使用括号保护的参数列表：

	function ([expression [, expression ... ]])
下面示例是通过函数调用计算2的平方根：

	sqrt(2)

参考内建函数和运算符，了解更多信息。

##### 聚集表达式
聚合表达式是指对于查询选择的所有数据记录上应用一个聚合函数。聚合函数在一组值上进行运算，并返回一个结果。例如：对一组值进行求和运算或者计算平均值。下面列出聚合表达式的语法结构：

* aggregate_name(expression [ , ... ] ) — 处理所有值为非空的输入记录值。
* aggregate_name(ALL expression [ , ... ] ) — 和上一个表达式行为一致，因为 ALL 是默认参数。
* aggregate_name(DISTINCT expression [ , ... ] ) — 处理所有去除重复后的非空输入记录值。
* aggregate_name(\*) — 处理所有输入记录值，非空值和空值都会被处理。通常这个表达式都是为count(\*)服务的。

上面表达式中的 aggregate_name 是一个预定义的聚合函数名称（可以使用模式限定名格式）。上面表达式中的 expression 可以是除聚合表达式自身外的任何值合法表达式。

例如，count(*) 返回输入记录的总数量，count(f1) 返回 f1 值中非空的总数量，count(distinct f1) 返回的是 f1 值中非空并去除重复值后的总数量。

要了解预定义的聚合函数，请参考内置函数和运算符。除了预定义聚合函数外，您还可以创建自定义的聚合函数。

Greenplum Database provides the MEDIAN aggregate function, which returns the fiftieth percentile of the PERCENTILE_CONT result and special aggregate expressions for inverse distribution functions as follows:

	PERCENTILE_CONT(_percentage_) WITHIN GROUP (ORDER BY _expression_)
	PERCENTILE_DISC(_percentage_) WITHIN GROUP (ORDER BY _expression_)
Currently you can use only these two expressions with the keyword WITHIN GROUP.

##### 聚合表达式的限制

下面列出了目前聚合表达式的限制：

* <&product-name>  does not support the following keywords: ALL, DISTINCT, FILTER and OVER. See Table 5 for more details.
* An aggregate expression can appear only in the result list or HAVING clause of a SELECT command. It is forbidden in other clauses, such as WHERE, because those clauses are logically evaluated before the results of aggregates form. This restriction applies to the query level to which the aggregate belongs.
* When an aggregate expression appears in a subquery, the aggregate is normally evaluated over the rows of the subquery. If the aggregate's arguments contain only outer-level variables, the aggregate belongs to the nearest such outer level and evaluates over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery in which it appears, and the aggregate expression acts as a constant over any one evaluation of that subquery. See Scalar Subqueries and Table 2.
* Greenplum Database does not support DISTINCT with multiple input expressions.

##### 窗口表达式
窗口表达式允许应用开发人员更加简单地通过标准SQL语言，来构建复杂的在线分析处理（OLAP）。例如，通过使用窗口表达式，用户可以计算移动平均值，某个范围内的总和，根据某些列值的变化重置聚合表达式或排名，还可以用简单的表达式表述复杂的比例关系。

窗口表达式表示在窗口帧上应用窗口函数，窗口帧是通过非常特别的OVER()子句定义的。窗口分区是分组后的应用于窗口函数的记录集合。与聚合函数针对每个分组的记录返回一个结果不同，窗口函数真对每行都返回结果，但是该值的计算是完全真对根据记录对应的窗口分区进行的。如果不指定分区，窗口函数就会在整个结果集赏进行计算。

窗口表达式的语法如下：

	window_function ( [expression [, ...]] ) OVER ( window_specification )

这里的 window_function 是表3列出的函数之一，表达式是任何不包含窗口表达式的合法值。window_specification 定义如下：

	[window_name]
	[PARTITION BY expression [, ...]]
	[[ORDER BY expression [ASC | DESC | USING operator] [, ...]
	    [{RANGE | ROWS} 
	       { UNBOUNDED PRECEDING
	       | expression PRECEDING
	       | CURRENT ROW
	       | BETWEEN window_frame_bound AND window_frame_bound }]]

上面的 window_frame_bound 定义如下:

	    UNBOUNDED PRECEDING
	    expression PRECEDING
	    CURRENT ROW
	    expression FOLLOWING
	    UNBOUNDED FOLLOWING

窗口表达式只能在 SELECT 的返回里表中出现。例如：

	SELECT count(*) OVER(PARTITION BY customer_id), * FROM sales;

OVER 子句是窗口函数与其他聚合函数或报表函数最大的区别。OVER clause 定义的 window_specification 确定了窗口函数应用的范围。窗口说明包含下面特征：

* PARTITION BY 子句定义应用于窗口函数上的窗口分区。如果省略此参数，整个结果集将会作为一个分区使用。
* ORDER BY 子句定义在窗口分区中用于排序的表达式。窗口说明中的 ORDER BY 子句和主查询中的 ORDER BY 子句是相互独立的。ORDER BY 子句对于计算排名的窗口函数来说是必需的，这是因为排序后才能获得排名值。对于在线分析处理聚合操作，窗口帧（ROWS 或 RANGE 子句）需要 ORDER BY 子句才能使用。
* ROWS/RANGE 子句为聚合窗口函数（非排名操作）定义一个窗口帧。窗口帧是在一个分区内的一组记录。定义了窗口帧之后，窗口函数将会在移动窗口帧上进行计算，而不是固定的在整个窗口分区上进行。窗口帧可以是基于记录分隔的也可以是基于值分隔的。

##### 类型转换
类型转换表达式可以将一个数据类型的数据转换为另一个数据类型。<&product-name> 支持下面两种等价的类型转换语法：

	CAST ( expression AS type )
	expression::type
CAST 的语法是符合 SQL 标准的的；而语法 :: 是 PostgreSQL 历史遗留的习惯。

对于已知类型值表达式的类型转换操作是运行时类型转换。只有当系统中适用的类型转换函数，类型转换才可能成功。这与直接在常量上应用类型转换并不相同。在字符串字面值上应用的类型转换代表了用字面值常量对一个类型进行初始赋值。因此，该字符串字面值只要是该类型接收的合法输入，该类型转换都会成功。

在一些位置上，表达式的值类型如果不会产生歧义时，显示类型转换是可以被省略的。例如，当为一张表的某个列赋值时，系统能够自动应用正确的类型转换。系统要应用自动类型转换规则的前提是，当且仅当系统表中定义隐式地类型转换是合法的。其他的类型转换，必需通过类型转换语法显示地进行调用。这样做可以阻止一部分用户意料之外的非期望类型转换的发生。

##### 标量子查询
标量子查询是指一个括号中的 SELECT 查询语句，并且该语句返回值是一行一列（一个值）。标量子查询不支持使用返回多行或多列的 SELECT 查询语句。外部查询运行并使用相关自查询的返回结果。相关标量子查询是指标量子查询中引用了外部查询变量的查询。

##### 相关子查询
相关子查询是指一个 SELECT 查询位于 返回列表或 WHERE 条件语句中，并引用了外部查询参数的查询语句。相关子查询允许更高效的表示出引用其他查询的返回结果。<&product-name> 能够支持相关子查询特性，此特性能够允许兼容很多已经存在的应用程序。相关子查询可以根据返回记录是一条还是多条，返回结果可以是标量或者表表达式，这取决于它返回的记录是一条还是多条。<&product-name> 目前不支持引用跨层的变量（不支持间接相关子查询）。

相关子查询示例
示例 1 – 标量相关子查询

	SELECT * FROM t1 WHERE t1.x 
	            > (SELECT MAX(t2.x) FROM t2 WHERE t2.y = t1.y);
示例 2 – 相关 EXISTS 子查询

	SELECT * FROM t1 WHERE 
	EXISTS (SELECT 1 FROM t2 WHERE t2.x = t1.x);
<&product-name> 利用下面两个算法来运行相关子查询：

* 将相关子查询展开成为连接运算：这种算是是最高效的方法，这也是 <&product-name> 对于大部分相关子查询使用的方法。一些 TPC-H 测试集中的查询都可以通过此方法进行优化。
* 对于引用的查询的每一条记录，都执行一次相关子查询：这是一种相对来说低效的算法。<&product-name> 对于位于 SELECT 返回列表中的相关子查和 WHERE 条件中 OR 连接表达式中的相关子查询使用这种算法。

下面的例子，向您展示对于不同类型的查询，如何通过查询重写来改进性能。

示例 3 - Select 返回列表中的相关子查询

原始查询

	SELECT T1.a,
	      (SELECT COUNT(DISTINCT T2.z) FROM t2 WHERE t1.x = t2.y) dt2 
	FROM t1;

重写后的查询首先与表 t1 执行内连接，再执行左外连接。查询重写只能对等值连接中的相关条件进行处理。

重写后的查询

	SELECT t1.a, dt2 FROM t1 
	       LEFT JOIN 
	        (SELECT t2.y AS csq_y, COUNT(DISTINCT t2.z) AS dt2 
	              FROM t1, t2 WHERE t1.x = t2.y 
	              GROUP BY t1.x) 
	       ON (t1.x = csq_y);
示例 4 - OR 子句中的相关子查询
原始查询

	SELECT * FROM t1 
	WHERE 
	x > (SELECT COUNT(*) FROM t2 WHERE t1.x = t2.x) 
	OR x < (SELECT COUNT(*) FROM t3 WHERE t1.y = t3.y)
重写后的查询是根据 OR 条件，将原来查询分成两个部分，并使用 UNION 进行连接。

重写后的查询

	SELECT * FROM t1 
	WHERE x > (SELECT count(*) FROM t2 WHERE t1.x = t2.x) 
	UNION 
	SELECT * FROM t1 
	WHERE x < (SELECT count(*) FROM t3 WHERE t1.y = t3.y)
要查看查询计划，可以使用 EXPLAIN SELECT 或者 EXPLAIN ANALYZE SELECT。查询计划中的 Subplan 节点代表查询将会对外部查询的每一条记录都处理一次，因此暗示着查询可能可以被重写和优化。

##### 高级“表”表达式
Greenplum Database supports table functions with TABLE value expressions. You can sort input rows for advanced table functions with an ORDER BY clause. You can redistribute them with a SCATTER BY clause to specify one or more columns or an expression for which rows with the specified characteristics are available to the same process. This usage is similar to using a DISTRIBUTED BY clause when creating a table, but the redistribution occurs when the query runs.

The following command uses the TABLE function with the SCATTER BY clause in the the GPText function gptext.index() to populate the index mytest.articles with data from the messages table:

	SELECT * FROM gptext.index(TABLE(SELECT * FROM messages 
	SCATTER BY distrib_id), 'mytest.articles');
Note:
Based on the distribution of data, Greenplum Database automatically parallelizes table functions with TABLE value parameters over the nodes of the cluster.

For information about the function gptext.index(), see the Pivotal GPText documentation.

##### 数组构造表达式
数据构造表达式是通过提供成员值的方式构造数组值的表达式。一个简单的数组构造表达式由：关键字 ARRAY，左方括号（[），用来组成数组元素值的通过逗号分隔的一个多个表达式，和一个右方括号（]）。例如：

	SELECT ARRAY[1,2,3+4];
	  array
	---------
	 {1,2,7}

数组元素的类型就是其成员表达式的公共类型，确定的方式和 UNION，CASE 构造器规则相同。

通过嵌套数组构造表达式，您还可以创建多维数组值。内部的数组构造器，可以省略关键字 ARRAY。例如，下面两个 SELECT 语句返回的结果完全相同：

	SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
	SELECT ARRAY[[1,2],[3,4]];
	     array
	---------------
	 {{1,2},{3,4}}

由于多维数组一定是矩形（长方形），在同一层的内部构造表达式产生的子数组必须拥有相同的维度。

多维数组构造表达器中的元素不一定是子数组构造表达式，它们可以是任何一个产生适当类型数组的表达式。例如：

	CREATE TABLE arr(f1 int[], f2 int[]);
	INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], 
	ARRAY[[5,6],[7,8]]);
	SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
	                     array
	------------------------------------------------
	 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}

你可以使用子查询的结果来构造数组。这里的数组构造表达式是关键字 ARRAY 开头，后面跟着在圆括号中的子查询。例如：

	SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
	                          ?column?
	-----------------------------------------------------------
	 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}


这里的子查询只能返回单列。生成的一维数组中的每个元素对应着子查询每一条记录，数组元素的类型是子查询输出列的类型。通过数组构造表达式得到的数组，下标总是从1开始编号。

##### 记录构造表达式
记录构造器是一种用来从成员值构建记录值的表达式（记录表达式也被称为复合类型）。例如：

	SELECT ROW(1,2.5,'this is a test');

记录构造表达式还支持语法 rowvalue.\* ，该表达式能够将记录值的成员展开成列表，这个操作类似于当你在 SELECT 目标列表时使用的 .\* 语法。例如，如果表 t 有两列 f1 和 f2，下面的查询是等价的：

	SELECT ROW(t.*, 42) FROM t;
	SELECT ROW(t.f1, t.f2, 42) FROM t;

记录构造表达式默认创建的记录值具有匿名记录类型。根据需要，您可以将该值通过类型转换表达式，转换成一个命名复合类型：数据表的记录类型或者是通过 CREATE TYPE AS 命令创建的复合类型。您可以显示地提供类型转来避免出现歧义。例如：

	CREATE TABLE mytable(f1 int, f2 float, f3 text);
	CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' 
	LANGUAGE SQL;

下面的查询语句中，因为全局只有一个 getf1() 函数，所以这里不产生任何的歧义，您也就不需要进行类型转换的处理：

	SELECT getf1(ROW(1,2.5,'this is a test'));
	 getf1
	-------
	     1
	CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
	CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT 
	$1.f1' LANGUAGE SQL;

下面的例子需要通过类型转换来指定具体调用的函数：

	SELECT getf1(ROW(1,2.5,'this is a test'));
	ERROR:  function getf1(record) is not unique
	SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
	 getf1
	-------
	     1
	SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS 
	myrowtype));
	 getf1
	-------
	    11

你可以使用记录构造器来构建复合值，将其存储在复合类型的列中或者将其传给接受复合类型参数的函数。

##### 表达式求值规则
自表达式的求值顺序是未定义的。运算符或者函数的求值不一定遵守从左到右的规则，也不保证按照任何特定顺序进行。

如果表达式的值能够由表达式中的一部分子表达式确定，那么其他部分的子表达式可能不会被求值。例如，下面的表达式：

	SELECT true OR somefunc();

somefunc() 函数可能不会被调用。类似的情况对下面例子也适用：

	SELECT somefunc() OR true;

这个特点和大多数编程语言中，布尔运算符求值顺序总是从左到右不太一样。

不要在复杂表达式中使用带有副作用的函数，特别是像 WHERE 或者 HAVING 子句。因为这里语句在生成查询计划过程中会被多次处理。在上面语句中的布尔表达式（AND/OR/NOT 组合）将会根据布尔代数规则重新排列成为任何最优合法结构。

您可以使用 CASE 结构来保证求值顺序。下面的示例就是一个不能保证避免除0错误的情况：

	SELECT ... WHERE x <> 0 AND y/x > 1.5;

下面的示例能够保证避免除0错误：

	SELECT ... WHERE CASE WHEN x <> 0 THEN y/x > 1.5 ELSE false END;
这种 CASE 结构将会阻止查询优化，因此请小心使用。

### 使用函数和运算符
<&product-name> 在 SQL 表达式中对函数和运算符进行求值。一些函数和运算符只能运行在主节点上，如果在计算节点运行，会导致结果出现不一致状态。

#### 如何使用函数
| 函数类型	| <&product-name> 支持情况 |	说明 |	备注 |
| --- | --- | ---| --- |
| IMMUTABLE |	完全支持 |	函数只直接依赖参数列表中提供的信息。对于相同的参数值，返回结果不变。 | 无 | 
| STABLE |	大部分情况支持 |	在一次的表扫描过程中，其返回结果对相同输入参数保持不变，但是结果在不同 SQL 语句之间会发生改变。|	其返回结果取决于数据库查询或参数值。例如：current_timestamp 家族的函数都是 STABLE 的。在一次执行中，该函数值保持不变。 |
| VOLATILE | 限制性的使用 | 在一次表扫描过程中，函数值也会发生变化。例如：random(), currval(), timeofday()。|	即使结果可以预测，任何带有副作用（side effects）的函数仍然属于易变函数。例如：setval()。|

在 <&product-name> 中, 数据被均匀的存储在多个计算节点上，每个计算节点都是一个 PostgreSQL 数据库。To prevent inconsistent or unexpected results, do not execute functions classified as VOLATILE at the segment level if they contain SQL commands or modify the database in any way. For example, functions such as setval() are not allowed to execute on distributed data in Greenplum Database because they can cause inconsistent data between segment instances.

为了确保数据的一致性，您可以在只运行在主节点上的语句中使用 VOLATILE 和 STABLE 类型的函数。例如：下面的命令在主节点上执行（语句中没有 FROM 子句）：

	SELECT setval('myseq', 201);
	SELECT foo();

如果If a statement has a FROM clause containing a distributed table and the function in the FROM clause returns a set of rows, the statement can run on the segments:

	SELECT * from foo();
Greenplum Database does not support functions that return a table reference (rangeFuncs) or functions that use the refCursor datatype.

#### 用户自定义函数
下个版本支持。敬请期待。

#### Built-in Functions and Operators
The following table lists the categories of built-in functions and operators supported by PostgreSQL. All functions and operators are supported in Greenplum Database as in PostgreSQL with the exception of STABLE and VOLATILE functions, which are subject to the restrictions noted in Using Functions in Greenplum Database. See the Functions and Operators section of the PostgreSQL documentation for more information about these built-in functions and operators.

# TODO